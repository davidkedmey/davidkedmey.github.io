<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>How Biomorphs Work — Biomorph Builder</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0a0e14;
      color: #d4dce6;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .header {
      width: 100%;
      max-width: 640px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px 24px 12px;
    }

    .header h1 {
      font-family: "SF Mono", "Fira Code", monospace;
      font-size: 1.1rem;
      color: #c8e6c8;
      font-weight: 600;
    }

    .header-nav {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .header-step {
      font-size: 0.8rem;
      color: #6a7a8a;
      font-family: "SF Mono", "Fira Code", monospace;
    }

    .hub-link {
      font-size: 0.8rem;
      color: #6a8a9a;
      text-decoration: none;
      border: 1px solid #2a3444;
      border-radius: 4px;
      padding: 4px 10px;
      transition: all 0.15s;
    }

    .hub-link:hover {
      background: #12161e;
      color: #c8e6c8;
    }

    .container {
      width: 100%;
      max-width: 640px;
      padding: 0 24px 40px;
      flex: 1;
    }

    .canvas-wrap {
      background: #12161e;
      border: 1px solid #2a3444;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 280px;
    }

    .canvas-wrap canvas { display: block; }

    .sliders {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin-top: 16px;
      width: 100%;
    }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 6px;
      background: #0a0e14;
      border: 1px solid #2a3444;
      border-radius: 6px;
      padding: 6px 10px;
      transition: border-color 0.3s, box-shadow 0.3s;
    }

    .slider-row.fresh {
      border-color: #5aaa6a;
      box-shadow: 0 0 12px rgba(100, 200, 120, 0.3);
      animation: pulse-fresh 1.5s ease-in-out infinite;
    }

    @keyframes pulse-fresh {
      0%, 100% { box-shadow: 0 0 8px rgba(100, 200, 120, 0.2); border-color: #5aaa6a; }
      50% { box-shadow: 0 0 18px rgba(100, 200, 120, 0.45); border-color: #6abf7a; }
    }

    .slider-row label {
      font-family: "SF Mono", "Fira Code", monospace;
      font-size: 0.7rem;
      color: #6a7a8a;
      min-width: 56px;
    }

    .slider-row input[type="range"] {
      width: 80px;
      accent-color: #4a6a5a;
    }

    .slider-row .val {
      font-family: "SF Mono", "Fira Code", monospace;
      font-size: 0.8rem;
      color: #c8e6c8;
      min-width: 24px;
      text-align: right;
    }

    .toggle-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 8px;
      width: 100%;
    }

    .toggle-btn {
      font-family: "SF Mono", "Fira Code", monospace;
      font-size: 0.72rem;
      padding: 5px 12px;
      border: 1px solid #2a3444;
      border-radius: 5px;
      background: transparent;
      color: #6a7a8a;
      cursor: pointer;
      transition: all 0.15s;
    }

    .toggle-btn:hover { background: #1a2a22; color: #aab8c8; }
    .toggle-btn.active { border-color: #4a6a5a; color: #c8e6c8; background: rgba(74,106,90,0.15); }

    .text-panel {
      background: #12161e;
      border: 1px solid #2a3444;
      border-left: 3px solid #4a6a5a;
      border-radius: 10px;
      padding: 20px 24px;
      margin-bottom: 16px;
    }

    .step-title {
      font-family: "SF Mono", "Fira Code", monospace;
      font-size: 0.95rem;
      color: #c8e6c8;
      margin-bottom: 10px;
      font-weight: 600;
    }

    .step-text {
      font-size: 0.92rem;
      color: #aab8c8;
      line-height: 1.75;
    }

    .step-text em {
      color: #c8e6c8;
      font-style: normal;
      font-weight: 500;
    }

    .step-text .action {
      display: block;
      margin-top: 12px;
      padding: 10px 14px;
      background: rgba(74, 106, 90, 0.12);
      border: 1px solid #2a4a3a;
      border-radius: 6px;
      color: #a8d8a8;
      font-size: 0.88rem;
    }

    .step-text .action::before {
      content: '\25B6\00a0\00a0';
      font-size: 0.7rem;
    }

    .step-text .quote {
      display: block;
      font-style: italic;
      color: #7a8a9a;
      border-left: 2px solid #3a5a4a;
      padding: 6px 0 6px 14px;
      margin: 14px 0 4px;
      font-size: 0.86rem;
      line-height: 1.65;
    }

    .step-text .quote-attr {
      display: block;
      color: #4a5a6a;
      font-style: normal;
      font-size: 0.76rem;
      margin-top: 4px;
      padding-left: 16px;
    }

    .step-nav {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 16px;
      padding: 4px 0 20px;
    }

    .step-nav button {
      font-size: 0.9rem;
      padding: 8px 20px;
      border: 1px solid #2a3444;
      border-radius: 6px;
      background: transparent;
      color: #8a9aaa;
      cursor: pointer;
      transition: all 0.15s;
    }

    .step-nav button:hover:not(:disabled) {
      background: #12161e;
      color: #c8e6c8;
      border-color: #4a6a5a;
    }

    .step-nav button:disabled {
      opacity: 0.25;
      cursor: default;
    }

    .step-dots {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .step-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: #2a3444;
      cursor: pointer;
      transition: all 0.2s;
    }

    .step-dot.active {
      background: #c8e6c8;
      transform: scale(1.3);
    }

    .step-dot:hover:not(.active) {
      background: #4a6a5a;
    }

    .links-row {
      display: flex;
      gap: 10px;
      margin-top: 14px;
      flex-wrap: wrap;
    }

    .links-row a {
      font-size: 0.82rem;
      color: #6a8a9a;
      text-decoration: none;
      border: 1px solid #2a3444;
      border-radius: 5px;
      padding: 6px 14px;
      transition: all 0.15s;
    }

    .links-row a:hover {
      background: #12161e;
      color: #c8e6c8;
      border-color: #4a6a5a;
    }

    .btn {
      font-size: 0.8rem;
      padding: 6px 16px;
      border: 1px solid #2a3444;
      border-radius: 5px;
      background: transparent;
      color: #8a9aaa;
      cursor: pointer;
      font-family: inherit;
      transition: all 0.15s;
      margin-top: 8px;
    }

    .btn:hover {
      background: #1a2a22;
      color: #c8e6c8;
    }

    @media (max-width: 500px) {
      .header { padding: 16px 16px 8px; }
      .header h1 { font-size: 0.95rem; }
      .container { padding: 0 16px 32px; }
      .canvas-wrap { padding: 14px; min-height: 220px; }
      .text-panel { padding: 16px 18px; }
      .slider-row input[type="range"] { width: 60px; }
    }
  </style>
</head>
<body>

  <div class="header">
    <h1>How Biomorphs Work</h1>
    <div class="header-nav">
      <span class="header-step" id="header-step">1 / 15</span>
      <a class="hub-link" href="../">Hub</a>
    </div>
  </div>

  <div class="container">
    <div class="canvas-wrap" id="canvas-wrap"></div>
    <div class="text-panel" id="text-panel"></div>
    <div class="step-nav">
      <button id="btn-prev">&lsaquo; Back</button>
      <div class="step-dots" id="dots"></div>
      <button id="btn-next">Next &rsaquo;</button>
    </div>
  </div>

<script type="module">
import { drawTree, defineVectors, MODE_CONFIGS, randomInteresting } from '../shared/genotype.js';

// ── Gene mapping: lesson order → Dawkins gene array index ──
const GENE_MAP =   [3, 0, 4, 1, 5, 2, 6, 7, 8, 9, 10, 11, 12];
const GENE_LABELS = [
  'Gene 1', 'Gene 2', 'Gene 3', 'Gene 4', 'Gene 5',
  'Gene 6', 'Gene 7', 'Gene 8', 'Depth',
  'Segments', 'Spacing', 'Grad 1', 'Grad 2',
];
const GENE_MINS = [-9, -9, -9, -9, -9, -9, -9, -9, 1,  1,  2, -9, -9];
const GENE_MAXS = [ 9,  9,  9,  9,  9,  9,  9,  9, 8,  8, 12,  9,  9];

// ── Rendering pipeline ──

function applySymmetry(lines, symType) {
  if (symType === 'left-right') return lines;
  const result = lines.slice();
  if (symType === 'up-down' || symType === 'four-way') {
    for (const seg of lines)
      result.push({ x0: seg.x0, y0: -seg.y0, x1: seg.x1, y1: -seg.y1, depth: seg.depth });
  }
  if (symType === 'four-way') {
    const soFar = result.slice();
    for (const seg of soFar)
      result.push({ x0: -seg.x0, y0: seg.y0, x1: -seg.x1, y1: seg.y1, depth: seg.depth });
  }
  return result;
}

function drawSegmented(genes, opts = {}) {
  const segCount = genes[9] || 1;
  const segDist = genes[10] || 4;
  const hasGradients = opts.gradients && genes.length >= 13;
  const allLines = [];
  for (let s = 0; s < segCount; s++) {
    let segGenes = genes.slice();
    if (hasGradients && segCount > 1) {
      const t = s / (segCount - 1);
      segGenes = segGenes.slice();
      segGenes[0] = Math.max(-9, Math.min(9, Math.round(genes[0] + genes[11] * t)));
      segGenes[2] = Math.max(-9, Math.min(9, Math.round(genes[2] + genes[12] * t)));
    }
    const treeLines = drawTree(segGenes);
    const yOffset = (s - (segCount - 1) / 2) * segDist;
    const symLines = opts.symmetry ? applySymmetry(treeLines, opts.symmetry) : treeLines;
    for (const seg of symLines)
      allLines.push({ x0: seg.x0, y0: seg.y0 + yOffset, x1: seg.x1, y1: seg.y1 + yOffset, depth: seg.depth });
  }
  return allLines;
}

function applyRadial(lines, arms) {
  if (!arms || arms <= 1) return lines;
  const result = [];
  const step = (2 * Math.PI) / arms;
  for (let a = 0; a < arms; a++) {
    const cos = Math.cos(step * a), sin = Math.sin(step * a);
    for (const seg of lines)
      result.push({
        x0: seg.x0 * cos - seg.y0 * sin, y0: seg.x0 * sin + seg.y0 * cos,
        x1: seg.x1 * cos - seg.y1 * sin, y1: seg.x1 * sin + seg.y1 * cos,
        depth: seg.depth,
      });
  }
  return result;
}

// ── State ──
let genes = [0, 0, 0, 5, 0, 0, 0, 0, 1];
let currentStep = 0;
let sliderEls = {};
let renderOpts = {};
let turtleAnim = null;
let traceAnim = null;
let useTrace = false;  // current step uses trace animation
let traceSkipCount = 0;
let traceSliderIndices = null; // which lesson indices trigger retrace (null = all)
let coordAnim = null;
let useCoordAnim = false;
let branchIntroAnim = null;
let showAllMode = null; // null or { lessonIdx, values }

const $cw = document.getElementById('canvas-wrap');
const $tp = document.getElementById('text-panel');
const $prev = document.getElementById('btn-prev');
const $next = document.getElementById('btn-next');
const $dots = document.getElementById('dots');
const $hs = document.getElementById('header-step');

// ── HiDPI canvas ──
const W = 380, H = 260;
const dpr = window.devicePixelRatio || 1;
const canvas = document.createElement('canvas');
canvas.width = W * dpr;
canvas.height = H * dpr;
canvas.style.width = W + 'px';
canvas.style.height = H + 'px';
const ctx = canvas.getContext('2d');
ctx.scale(dpr, dpr);

const $sliders = document.createElement('div');
$sliders.className = 'sliders';
const $toggles = document.createElement('div');
$toggles.className = 'toggle-row';
$toggles.style.display = 'none';

// ── Turtle intro animation (step 1) ──
function startTurtleAnim() {
  turtleAnim = { start: performance.now(), duration: 1800 };
  function tick() {
    if (!turtleAnim) return;
    draw();
    if (performance.now() - turtleAnim.start < turtleAnim.duration)
      requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
}

// ── Trace animation (slides 3-5) ──
function startTrace(msPerLine = 300, skipCount = 0) {
  traceAnim = { start: performance.now(), msPerLine, skipCount };
  function tick() {
    if (!traceAnim) return;
    draw();
    const lines = computeLines();
    const tracedCount = lines.length - skipCount;
    const elapsed = performance.now() - traceAnim.start;
    const lineIdx = Math.floor(elapsed / traceAnim.msPerLine);
    const frac = (elapsed % traceAnim.msPerLine) / traceAnim.msPerLine;
    // Done when last traced line is fully drawn
    if (lineIdx >= tracedCount || (lineIdx === tracedCount - 1 && frac >= 0.99)) {
      traceAnim = null;
      draw(); // final frame without dot
    } else {
      requestAnimationFrame(tick);
    }
  }
  requestAnimationFrame(tick);
}

// ── Coordinate building animation ──
function startCoordAnim() {
  coordAnim = { start: performance.now() };
  const dx = genes[0], dy = genes[4];
  const p1 = dx !== 0 ? 600 : 0;
  const p2 = dy !== 0 ? 600 : 0;
  const total = p1 + p2 + 400 + 300;
  function tick() {
    if (!coordAnim) return;
    draw();
    if (performance.now() - coordAnim.start > total) {
      coordAnim = null;
      draw();
    } else {
      requestAnimationFrame(tick);
    }
  }
  requestAnimationFrame(tick);
}

// ── Branch intro animation (slide 5) ──
function startBranchIntroAnim() {
  branchIntroAnim = { start: performance.now() };
  const g2 = genes[0], g3 = genes[4];
  const P1 = g2 !== 0 ? 500 : 0;
  const P2 = g3 !== 0 ? 500 : 0;
  const total = P1 + P2 + 400 + 400 + 200;
  function tick() {
    if (!branchIntroAnim) return;
    draw();
    if (performance.now() - branchIntroAnim.start > total) {
      branchIntroAnim = null;
      draw();
    } else {
      requestAnimationFrame(tick);
    }
  }
  requestAnimationFrame(tick);
}

// ── Compute lines from current state ──
function computeLines() {
  const hasSegs = genes.length > 9 && genes[9] > 1;
  let lines;
  if (hasSegs) {
    lines = drawSegmented(genes, renderOpts);
  } else {
    lines = drawTree(genes);
    if (renderOpts.symmetry) lines = applySymmetry(lines, renderOpts.symmetry);
  }
  if (renderOpts.radial) {
    const segCount = genes[9] || 1;
    lines = applyRadial(lines, segCount > 1 ? segCount : 5);
  }
  return lines;
}

// ── Direction grid visualization (supports coordAnim) ──
function drawDirectionGrid() {
  const pad = 30;
  const gridSize = Math.min(W, H) - pad * 2;
  const cx = W / 2, cy = H / 2;
  const unit = gridSize / 18;

  // Grid lines
  ctx.strokeStyle = '#1a2028';
  ctx.lineWidth = 1;
  for (let i = -9; i <= 9; i++) {
    if (i === 0) continue;
    ctx.beginPath();
    ctx.moveTo(cx + i * unit, cy - 9 * unit);
    ctx.lineTo(cx + i * unit, cy + 9 * unit);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx - 9 * unit, cy + i * unit);
    ctx.lineTo(cx + 9 * unit, cy + i * unit);
    ctx.stroke();
  }

  // Axes
  ctx.strokeStyle = '#2a3a4a';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(cx - 9 * unit, cy);
  ctx.lineTo(cx + 9 * unit, cy);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx, cy - 9 * unit);
  ctx.lineTo(cx, cy + 9 * unit);
  ctx.stroke();

  // Axis labels
  ctx.fillStyle = '#3a4a5a';
  ctx.font = '9px "SF Mono", monospace';
  ctx.textAlign = 'right';
  ctx.fillText('sideways \u2192', cx + 9 * unit, cy + 14);
  ctx.textAlign = 'left';
  ctx.fillText('\u2191 up', cx + 5, cy - 9 * unit + 6);

  const dx = genes[0]; // Gene 2
  const dy = genes[4]; // Gene 3

  // Animation progress (all 1 when static/complete)
  const P1 = 600, P2 = 600, P3 = 400;
  let hProg = 1, vProg = 1, aProg = 1;
  if (coordAnim) {
    const el = performance.now() - coordAnim.start;
    hProg = dx !== 0 ? Math.min(1, el / P1) : 1;
    const vStart = dx !== 0 ? P1 : 0;
    vProg = dy !== 0 ? Math.min(1, Math.max(0, (el - vStart) / P2)) : 1;
    const aStart = vStart + (dy !== 0 ? P2 : 0);
    aProg = Math.min(1, Math.max(0, (el - aStart) / P3));
  }

  // Horizontal dotted projection
  if (dx !== 0 && hProg > 0) {
    ctx.setLineDash([3, 4]);
    ctx.strokeStyle = '#6a9a7a';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + dx * unit * hProg, cy);
    ctx.stroke();
  }

  // Vertical dotted projection
  if (dy !== 0 && vProg > 0) {
    ctx.setLineDash([3, 4]);
    ctx.strokeStyle = '#6a9a7a';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(cx + dx * unit, cy);
    ctx.lineTo(cx + dx * unit, cy - dy * unit * vProg);
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // Direction arrow
  if ((dx !== 0 || dy !== 0) && aProg > 0) {
    const ax = cx + dx * unit * aProg;
    const ay = cy - dy * unit * aProg;
    ctx.strokeStyle = 'hsl(150, 55%, 55%)';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(ax, ay);
    ctx.stroke();

    // Arrowhead (only when arrow is complete)
    if (aProg >= 0.99) {
      const fx = cx + dx * unit, fy = cy - dy * unit;
      const len = Math.sqrt((fx - cx) ** 2 + (fy - cy) ** 2);
      if (len > 0) {
        const ux = (fx - cx) / len, uy = (fy - cy) / len;
        const hl = 8;
        ctx.fillStyle = 'hsl(150, 55%, 55%)';
        ctx.beginPath();
        ctx.moveTo(fx, fy);
        ctx.lineTo(fx - hl * ux + hl * 0.4 * uy, fy - hl * uy - hl * 0.4 * ux);
        ctx.lineTo(fx - hl * ux - hl * 0.4 * uy, fy - hl * uy + hl * 0.4 * ux);
        ctx.fill();
      }
    }
  }

  // Animated dot at current front
  if (coordAnim) {
    const el = performance.now() - coordAnim.start;
    const vStart = dx !== 0 ? P1 : 0;
    const aStart = vStart + (dy !== 0 ? P2 : 0);
    let dotX = cx, dotY = cy;
    if (el < P1 && dx !== 0) {
      dotX = cx + dx * unit * hProg; dotY = cy;
    } else if (el < aStart) {
      dotX = cx + dx * unit; dotY = cy - dy * unit * vProg;
    } else {
      dotX = cx + dx * unit * aProg; dotY = cy - dy * unit * aProg;
    }
    ctx.fillStyle = '#c8e6c8';
    ctx.beginPath();
    ctx.arc(dotX, dotY, 4, 0, Math.PI * 2);
    ctx.fill();
  }

  // Origin dot
  ctx.fillStyle = '#4a6a5a';
  ctx.beginPath();
  ctx.arc(cx, cy, 3, 0, Math.PI * 2);
  ctx.fill();

  // Tip dot (when complete)
  if (aProg >= 0.99 && (dx !== 0 || dy !== 0)) {
    ctx.fillStyle = '#c8e6c8';
    ctx.beginPath();
    ctx.arc(cx + dx * unit, cy - dy * unit, 4, 0, Math.PI * 2);
    ctx.fill();
  }

  // Labels (appear after relevant phase completes)
  ctx.font = '11px "SF Mono", monospace';
  ctx.textAlign = 'center';
  if (dx !== 0 && hProg >= 0.99) {
    ctx.fillStyle = '#6a8a7a';
    ctx.fillText(`Gene 2 = ${dx}`, cx + dx * unit / 2, cy + 16);
  }
  if (dy !== 0 && vProg >= 0.99) {
    ctx.fillStyle = '#6a8a7a';
    const lx = cx + dx * unit + (dx >= 0 ? 8 : -8);
    ctx.textAlign = dx >= 0 ? 'left' : 'right';
    ctx.fillText(`Gene 3 = ${dy}`, lx, cy - dy * unit / 2);
    ctx.textAlign = 'center';
  }
}

// ── Show-all view: draw many variants side by side ──
function drawShowAll() {
  const { lessonIdx, values } = showAllMode;
  const gIdx = GENE_MAP[lessonIdx];
  const currentVal = genes[gIdx];
  const count = values.length;
  const cellW = W / count;
  const savedVal = genes[gIdx];

  // First pass: compute line sets and global bounds
  const allLineSets = [];
  let gMinY = Infinity, gMaxY = -Infinity, maxCellBW = 0;
  for (const val of values) {
    genes[gIdx] = val;
    let lines = computeLines();
    if (renderOpts.flipY) lines = lines.map(s => ({ ...s, y0: -s.y0, y1: -s.y1 }));
    allLineSets.push(lines);
    let lMinX = 0, lMaxX = 0;
    for (const s of lines) {
      gMinY = Math.min(gMinY, s.y0, s.y1);
      gMaxY = Math.max(gMaxY, s.y0, s.y1);
      lMinX = Math.min(lMinX, s.x0, s.x1);
      lMaxX = Math.max(lMaxX, s.x0, s.x1);
    }
    maxCellBW = Math.max(maxCellBW, lMaxX - lMinX);
  }
  genes[gIdx] = savedVal;

  const gbh = gMaxY - gMinY || 1;
  maxCellBW = maxCellBW || 1;
  const pad = 8;
  let scale;
  if (renderOpts.originBottom) {
    // Scale so everything fits above the origin (near bottom)
    const spaceUp = (H - 30) - pad;
    let s = 999;
    if (gMinY < 0) s = Math.min(s, spaceUp / (-gMinY));
    if (gMaxY > 0) s = Math.min(s, 20 / gMaxY);
    if (maxCellBW > 0) s = Math.min(s, (cellW - pad * 2) / maxCellBW);
    scale = s;
  } else {
    scale = Math.min((cellW - pad * 2) / maxCellBW, (H - 36 - pad * 2) / gbh);
  }

  // Second pass: draw
  for (let i = 0; i < count; i++) {
    const lines = allLineSets[i];
    const cx = cellW * i + cellW / 2;
    // Pin origin to bottom when originBottom is set, else center
    const cy = renderOpts.originBottom ? (H - 30) : (H - 24) / 2;
    const cellOY = renderOpts.originBottom ? 0 : goy;
    const isActive = values[i] === currentVal;

    if (lines.length === 0) {
      ctx.fillStyle = '#2a3444';
      ctx.font = '10px "SF Mono", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('\u00b7', cx, cy);
    } else {
      let lMinX = Infinity, lMaxX = -Infinity;
      for (const s of lines) { lMinX = Math.min(lMinX, s.x0, s.x1); lMaxX = Math.max(lMaxX, s.x0, s.x1); }
      const lox = (lMinX + lMaxX) / 2;
      const maxD = Math.max(...lines.map(s => s.depth));

      for (const seg of lines) {
        const sx0 = cx + (seg.x0 - lox) * scale;
        const sy0 = cy + (seg.y0 - cellOY) * scale;
        const sx1 = cx + (seg.x1 - lox) * scale;
        const sy1 = cy + (seg.y1 - cellOY) * scale;
        if (isActive) {
          const t = maxD > 1 ? (seg.depth - 1) / (maxD - 1) : 0;
          ctx.strokeStyle = `hsl(${110 + t * 60}, 55%, ${40 + t * 25}%)`;
          ctx.lineWidth = 2;
        } else {
          ctx.strokeStyle = 'hsl(150, 25%, 28%)';
          ctx.lineWidth = 1;
        }
        ctx.beginPath();
        ctx.moveTo(sx0, sy0);
        ctx.lineTo(sx1, sy1);
        ctx.stroke();
      }
    }

    // Value label
    ctx.fillStyle = isActive ? '#c8e6c8' : '#4a5a6a';
    ctx.font = `${isActive ? '11' : '9'}px "SF Mono", monospace`;
    ctx.textAlign = 'center';
    ctx.fillText(values[i], cx, H - 6);
  }
}

// ── Main draw ──
function draw() {
  ctx.clearRect(0, 0, W, H);

  // Turtle intro animation (step 1)
  if (turtleAnim) {
    const elapsed = performance.now() - turtleAnim.start;
    const t = Math.min(1, elapsed / turtleAnim.duration);
    const stemLen = 100;
    const baseY = H - 30;
    ctx.strokeStyle = 'hsl(150, 55%, 55%)';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(W / 2, baseY);
    ctx.lineTo(W / 2, baseY - stemLen * t);
    ctx.stroke();
    ctx.fillStyle = '#c8e6c8';
    ctx.beginPath();
    ctx.arc(W / 2, baseY - stemLen * t, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#4a6a5a';
    ctx.beginPath();
    ctx.arc(W / 2, baseY, 3, 0, Math.PI * 2);
    ctx.fill();
    return;
  }

  // Direction grid mode (also handles coordAnim)
  if (renderOpts.directionMode) {
    drawDirectionGrid();
    return;
  }

  // Show-all comparison view
  if (showAllMode) {
    drawShowAll();
    return;
  }

  let lines = computeLines();
  // Flip Y so positive values draw upward (natural tree orientation)
  if (renderOpts.flipY) {
    lines = lines.map(s => ({ ...s, y0: -s.y0, y1: -s.y1 }));
  }
  if (!lines.length) {
    ctx.fillStyle = '#4a5a6a';
    ctx.font = '13px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('(all zeros \u2014 nothing to draw)', W / 2, H / 2);
    return;
  }

  // Compute bounds from ALL lines (stable framing during trace)
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const s of lines) {
    minX = Math.min(minX, s.x0, s.x1);
    maxX = Math.max(maxX, s.x0, s.x1);
    minY = Math.min(minY, s.y0, s.y1);
    maxY = Math.max(maxY, s.y0, s.y1);
  }
  const bw = maxX - minX || 1, bh = maxY - minY || 1;
  const pad = 20;
  let scale, cx, cy, ox, oy;
  if (renderOpts.originBottom) {
    // Pin origin (0,0) near the bottom of the canvas
    cx = W / 2;
    cy = H - 30;
    ox = 0;
    oy = 0;
    // Scale to fit all lines within available space around pinned origin
    const spaceUp = cy - pad;
    const spaceDown = H - cy - 5;
    const spaceH = (W - pad * 2) / 2;
    let s = 999;
    if (minY < 0) s = Math.min(s, spaceUp / (-minY));
    if (maxY > 0) s = Math.min(s, spaceDown / maxY);
    if (bw > 0) s = Math.min(s, spaceH / (bw / 2));
    // Cap max scale so tiny forms don't look absurdly large
    scale = Math.min(s, renderOpts.maxScale || 999);
  } else {
    cx = W / 2;
    cy = H / 2;
    ox = (minX + maxX) / 2;
    oy = (minY + maxY) / 2;
    scale = renderOpts.fixedScale || Math.min((W - pad * 2) / bw, (H - pad * 2) / bh);
  }
  const maxD = Math.max(...lines.map(s => s.depth));

  function lineColor(seg) {
    if (maxD <= 1) return { color: 'hsl(150, 55%, 55%)', lw: 2.5 };
    const t = (seg.depth - 1) / (maxD - 1);
    return {
      color: `hsl(${110 + t * 60}, 55%, ${40 + t * 25}%)`,
      lw: 2 + t,
    };
  }

  function screenXY(px, py) {
    return [cx + (px - ox) * scale, cy + (py - oy) * scale];
  }

  function renderSeg(seg, fraction = 1) {
    const [sx0, sy0] = screenXY(seg.x0, seg.y0);
    const [sx1, sy1] = screenXY(seg.x1, seg.y1);
    const ex = sx0 + (sx1 - sx0) * fraction;
    const ey = sy0 + (sy1 - sy0) * fraction;
    const { color, lw } = lineColor(seg);
    ctx.strokeStyle = color;
    ctx.lineWidth = lw;
    ctx.beginPath();
    ctx.moveTo(sx0, sy0);
    ctx.lineTo(ex, ey);
    ctx.stroke();
    return [ex, ey];
  }

  // Trace animation: progressive reveal with traveling dot
  if (traceAnim) {
    const { skipCount = 0 } = traceAnim;
    // Draw pre-rendered (skipped) lines immediately
    for (let i = 0; i < Math.min(skipCount, lines.length); i++) renderSeg(lines[i]);

    const tracedLines = lines.slice(skipCount);
    const elapsed = performance.now() - traceAnim.start;
    const lineIdx = Math.floor(elapsed / traceAnim.msPerLine);
    const lineFrac = Math.min(1, (elapsed % traceAnim.msPerLine) / traceAnim.msPerLine);

    // Draw fully completed traced lines
    const completeCount = Math.min(lineIdx, tracedLines.length);
    for (let i = 0; i < completeCount; i++) renderSeg(tracedLines[i]);

    // Draw current traced line partially + dot
    if (lineIdx < tracedLines.length) {
      const [ex, ey] = renderSeg(tracedLines[lineIdx], lineFrac);
      ctx.fillStyle = '#c8e6c8';
      ctx.beginPath();
      ctx.arc(ex, ey, 4, 0, Math.PI * 2);
      ctx.fill();
    }

    // Start dot
    const [startX, startY] = screenXY(0, 0);
    ctx.fillStyle = '#4a6a5a';
    ctx.beginPath();
    ctx.arc(startX, startY, 3, 0, Math.PI * 2);
    ctx.fill();
    return;
  }

  // Branch intro animation: annotation builds, then branches draw
  if (branchIntroAnim && renderOpts.branchAnnotation && lines.length >= 3) {
    const elapsed = performance.now() - branchIntroAnim.start;
    const g2 = genes[0], g3 = genes[4], g1val = genes[3], d = genes[8];

    // Phase timings
    const P1 = g2 !== 0 ? 500 : 0;  // horizontal dotted
    const P2 = g3 !== 0 ? 500 : 0;  // vertical dotted
    const P3 = 400;                   // right branch
    const P4 = 400;                   // left branch

    // Always draw trunk
    renderSeg(lines[0]);

    // Trunk tip and annotation endpoints in screen coords
    const tipSX = cx + (0 - ox) * scale;
    const tipSY = cy + (-d * g1val - oy) * scale;
    const hEndSX = cx + (g2 - ox) * scale;
    const hEndSY = tipSY;
    const bEndSX = hEndSX;
    const bEndSY = cy + (-(d * g1val + g3) - oy) * scale;

    // Phase progress
    const hProg = g2 !== 0 ? Math.min(1, elapsed / P1) : 1;
    const vStart = P1;
    const vProg = g3 !== 0 ? Math.min(1, Math.max(0, (elapsed - vStart) / P2)) : 1;
    const rStart = vStart + P2;
    const rProg = Math.min(1, Math.max(0, (elapsed - rStart) / P3));
    const lStart = rStart + P3;
    const lProg = Math.min(1, Math.max(0, (elapsed - lStart) / P4));

    // Horizontal dotted line (Gene 2 component)
    if (g2 !== 0 && hProg > 0) {
      ctx.setLineDash([3, 4]);
      ctx.strokeStyle = 'rgba(120, 170, 140, 0.6)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(tipSX, tipSY);
      ctx.lineTo(tipSX + (hEndSX - tipSX) * hProg, tipSY);
      ctx.stroke();
      ctx.setLineDash([]);
      // Label appears when line is complete
      if (hProg >= 0.99) {
        ctx.fillStyle = '#6a8a7a';
        ctx.font = '10px "SF Mono", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`Gene 2 = ${g2}`, (tipSX + hEndSX) / 2, tipSY + 14);
      }
    }

    // Vertical dotted line (Gene 3 component)
    if (g3 !== 0 && vProg > 0) {
      ctx.setLineDash([3, 4]);
      ctx.strokeStyle = 'rgba(120, 170, 140, 0.6)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(hEndSX, hEndSY);
      ctx.lineTo(hEndSX, hEndSY + (bEndSY - hEndSY) * vProg);
      ctx.stroke();
      ctx.setLineDash([]);
      if (vProg >= 0.99) {
        ctx.fillStyle = '#6a8a7a';
        ctx.font = '10px "SF Mono", monospace';
        ctx.textAlign = 'left';
        ctx.fillText(`Gene 3 = ${g3}`, hEndSX + 6, (hEndSY + bEndSY) / 2 + 3);
      }
    }

    // Right branch (lines[2]) draws after annotation
    if (rProg > 0) {
      const [ex, ey] = renderSeg(lines[2], rProg);
      if (rProg < 1) {
        ctx.fillStyle = '#c8e6c8';
        ctx.beginPath();
        ctx.arc(ex, ey, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Left branch (lines[1]) draws last
    if (lProg > 0) {
      const [ex, ey] = renderSeg(lines[1], lProg);
      if (lProg < 1) {
        ctx.fillStyle = '#c8e6c8';
        ctx.beginPath();
        ctx.arc(ex, ey, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    return;
  }

  // Normal render: all lines
  for (const seg of lines) renderSeg(seg);

  // Branch annotation: show right triangle decomposition on right branch
  if (renderOpts.branchAnnotation) {
    const g2 = genes[0]; // Gene 2 (horizontal spread) = g1 in Dawkins
    const g3 = genes[4]; // Gene 3 (vertical reach) = g5 in Dawkins
    const g1val = genes[3]; // Gene 1 (stem) = g4 in Dawkins
    const d = genes[8]; // depth

    if (g3 !== 0 && g2 !== 0) {
      // Trunk tip in gene coords (after flipY): (0, -d*g1val)
      const tipSX = cx + (0 - ox) * scale;
      const tipSY = cy + (-d * g1val - oy) * scale;
      // Horizontal end: (g2, -d*g1val)
      const hEndSX = cx + (g2 - ox) * scale;
      const hEndSY = tipSY;
      // Branch end: (g2, -(d*g1val + g3))
      const bEndSX = hEndSX;
      const bEndSY = cy + (-(d * g1val + g3) - oy) * scale;

      // Horizontal dotted line (Gene 2 component)
      ctx.setLineDash([3, 4]);
      ctx.strokeStyle = 'rgba(120, 170, 140, 0.6)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(tipSX, tipSY);
      ctx.lineTo(hEndSX, hEndSY);
      ctx.stroke();

      // Vertical dotted line (Gene 3 component)
      ctx.beginPath();
      ctx.moveTo(hEndSX, hEndSY);
      ctx.lineTo(bEndSX, bEndSY);
      ctx.stroke();
      ctx.setLineDash([]);

      // Gene 2 label (below horizontal line)
      ctx.fillStyle = '#6a8a7a';
      ctx.font = '10px "SF Mono", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`Gene 2 = ${g2}`, (tipSX + hEndSX) / 2, tipSY + 14);

      // Gene 3 label (beside vertical line)
      ctx.textAlign = 'left';
      ctx.fillText(`Gene 3 = ${g3}`, hEndSX + 6, (hEndSY + bEndSY) / 2 + 3);
    } else if (g3 !== 0) {
      // Only vertical (g2=0): show label on the branch itself
      const tipSY = cy + (-d * g1val - oy) * scale;
      const bEndSY = cy + (-(d * g1val + g3) - oy) * scale;
      ctx.fillStyle = '#6a8a7a';
      ctx.font = '10px "SF Mono", monospace';
      ctx.textAlign = 'left';
      ctx.fillText(`Gene 3 = ${g3}`, cx + 6, (tipSY + bEndSY) / 2 + 3);
    }
  }
}

// ── Slider management ──
function showSliders(lessonIndices, freshLessonIndex, rangeOverrides) {
  const ov = rangeOverrides || {};
  for (const li of Object.keys(sliderEls)) {
    if (!lessonIndices.includes(parseInt(li))) {
      sliderEls[li].row.remove();
      delete sliderEls[li];
    }
  }
  for (const li of lessonIndices) {
    const gIdx = GENE_MAP[li];
    const mn = ov[li]?.min ?? GENE_MINS[li];
    const mx = ov[li]?.max ?? GENE_MAXS[li];
    if (!sliderEls[li]) {
      const row = document.createElement('div');
      row.className = 'slider-row';
      const lbl = document.createElement('label');
      lbl.textContent = GENE_LABELS[li];
      row.appendChild(lbl);
      const input = document.createElement('input');
      input.type = 'range';
      input.min = mn;
      input.max = mx;
      input.value = genes[gIdx];
      row.appendChild(input);
      const valSpan = document.createElement('span');
      valSpan.className = 'val';
      valSpan.textContent = genes[gIdx];
      row.appendChild(valSpan);
      input.addEventListener('input', () => {
        genes[gIdx] = parseInt(input.value);
        valSpan.textContent = genes[gIdx];
        // Per-slider behavior: only retrace for specific genes
        if (useTrace && traceSliderIndices && traceSliderIndices.includes(li)) startTrace(200, traceSkipCount);
        else if (useCoordAnim) startCoordAnim();
        else { traceAnim = null; draw(); }
      });
      $sliders.appendChild(row);
      sliderEls[li] = { input, valSpan, row };
    } else {
      sliderEls[li].input.min = mn;
      sliderEls[li].input.max = mx;
      sliderEls[li].input.value = genes[gIdx];
      sliderEls[li].valSpan.textContent = genes[gIdx];
    }
  }
  for (const li of lessonIndices) $sliders.appendChild(sliderEls[li].row);
  for (const li of lessonIndices)
    sliderEls[li].row.classList.toggle('fresh', li === freshLessonIndex);
}

function showToggles(config) {
  $toggles.innerHTML = '';
  $toggles.style.display = 'none';
  if (!config) return;
  $toggles.style.display = 'flex';
  for (const item of config) {
    const btn = document.createElement('button');
    btn.className = 'toggle-btn';
    btn.textContent = item.label;
    if (item.active) btn.classList.add('active');
    btn.addEventListener('click', () => {
      item.onClick();
      $toggles.querySelectorAll('.toggle-btn').forEach((b, i) => {
        b.classList.toggle('active', config[i].isActive());
      });
      draw();
    });
    $toggles.appendChild(btn);
  }
}

// ── Index sets ──
const L_STEM = [0];
const L_INNER = [0, 1];
const L_TILT = [0, 1, 2];
const L_DEPTH = [0, 1, 2, 8];
const L_ALL8 = [0, 1, 2, 3, 4, 5, 6, 7];
const L_ALL9 = [0, 1, 2, 3, 4, 5, 6, 7, 8];
const L_SEGS = [...L_ALL9, 9];
const L_SPACING = [...L_ALL9, 9, 10];
const L_GRADS = [...L_ALL9, 9, 10, 11, 12];

// ── Steps ──
const steps = [

  // ═══ 0: The Hook ═══
  {
    setup() {
      genes = [-4, 5, -2, 3, -6, 4, 7, -3, 7];
      turtleAnim = null; traceAnim = null; useTrace = false;
      renderOpts = {};
      showSliders([], null);
      showToggles(null);
    },
    text: `
      <div class="step-title">This is a biomorph</div>
      <div class="step-text">
        <span class="quote">"I was genuinely astonished and delighted at the richness of morphological types that emerged before my eyes as I bred."</span>
        A digital creature built entirely from <em>9 numbers</em>.
        <br><br>
        No artist drew this. A simple algorithm read 9 numbers and drew every line you see. Let's find out how.
      </div>
    `,
  },

  // ═══ 1: Meet the Turtle ═══
  {
    setup() {
      genes = [0, 0, 0, 5, 0, 0, 0, 0, 1];
      traceAnim = null; useTrace = false;
      renderOpts = {};
      showSliders([], null);
      showToggles(null);
      startTurtleAnim();
    },
    text: `
      <div class="step-title">Meet the turtle</div>
      <div class="step-text">
        The algorithm works like a <em>turtle</em> with a pen. It starts at a point and walks in a direction, drawing a line behind it.
        <br><br>
        That's it. One turtle, one direction, one line. Everything else builds on this.
      </div>
    `,
  },

  // ═══ 2: The Stem ═══
  {
    setup() {
      genes = [0, 0, 0, 5, 0, 0, 0, 0, 1];
      turtleAnim = null; useTrace = false; traceSkipCount = 0;
      renderOpts = { flipY: true, originBottom: true, maxScale: 20 };
      showSliders(L_STEM, 0, { 0: { min: 1 } });
      showToggles(null);
      startTrace(400);
    },
    text: `
      <div class="step-title">The stem</div>
      <div class="step-text">
        <em>Gene 1</em> controls how far the turtle walks \u2014 the height of the central stem.
        <span class="action">Drag Gene 1 to change the height, or tap "Show all" to see every value at once.</span>
      </div>
    `,
    extra() {
      const btn = document.createElement('button');
      btn.className = 'btn extra-row';
      btn.textContent = 'Show all values';
      btn.addEventListener('click', () => {
        if (showAllMode) {
          showAllMode = null;
          btn.textContent = 'Show all values';
        } else {
          showAllMode = { lessonIdx: 0, values: [1, 2, 3, 4, 5, 6, 7, 8, 9] };
          btn.textContent = 'Single view';
        }
        traceAnim = null;
        draw();
      });
      $cw.appendChild(btn);
    },
  },

  // ═══ 3: Walk and Split ═══
  {
    setup() {
      genes[3] = 3; // Gene 1 (stem)
      genes[0] = 5; // Gene 2 (spread)
      genes[8] = 2; // depth 2 so trunk + one level of branches
      turtleAnim = null; useTrace = false; traceSkipCount = 1;
      traceSliderIndices = null;
      renderOpts = { flipY: true, originBottom: true, maxScale: 20 };
      showSliders(L_INNER, 1, { 0: { min: 1 }, 1: { min: 0 } });
      showToggles(null);
      startTrace(500, 1); // initial entry animation only
    },
    text: `
      <div class="step-title">Walk and split</div>
      <div class="step-text">
        When the turtle reaches the end of the stem, it <em>clones itself into two children</em>. Watch: one walks left, then one walks right \u2014 always mirrored.
        <br><br>
        <em>Gene 2</em> controls how far apart they spread.
        <span class="action">Drag Gene 2 to change the spread, or tap "Show all" to compare.</span>
      </div>
    `,
    extra() {
      const btn = document.createElement('button');
      btn.className = 'btn extra-row';
      btn.textContent = 'Show all spreads';
      btn.addEventListener('click', () => {
        if (showAllMode) {
          showAllMode = null;
          btn.textContent = 'Show all spreads';
        } else {
          showAllMode = { lessonIdx: 1, values: [0, 1, 3, 5, 7, 9] };
          btn.textContent = 'Single view';
        }
        traceAnim = null;
        draw();
      });
      $cw.appendChild(btn);
    },
  },

  // ═══ 4: Angled branches ═══
  {
    setup() {
      // Keep Gene 1 and Gene 2 from previous slide, add Gene 3
      if (genes[3] < 1) genes[3] = 3;
      if (genes[0] < 1) genes[0] = 5;
      genes[4] = 4; // Gene 3 (vertical reach) \u2014 start visible
      genes[8] = 2;
      turtleAnim = null; traceAnim = null;
      useTrace = false;
      renderOpts = { flipY: true, originBottom: true, maxScale: 20, branchAnnotation: true };
      showSliders(L_TILT, 2, { 0: { min: 1 }, 1: { min: 0 } });
      showToggles(null);
      startBranchIntroAnim();
    },
    text: `
      <div class="step-title">Angled branches</div>
      <div class="step-text">
        So far the branches go straight sideways. <em>Gene 3</em> tilts them \u2014 it adds a vertical component.
        <br><br>
        Gene 2 says how far sideways. Gene 3 says how far up or down. The branch follows the diagonal \u2014 the dotted lines show the two components.
        <br><br>
        Set Gene 3 to <em>negative</em> and the branches droop downward instead.
        <span class="action">Drag Gene 3 to tilt the branches. Try positive and negative values.</span>
      </div>
    `,
  },

  // ═══ 6: Turtles All the Way Down ═══
  {
    setup() {
      if (genes[3] < 2) genes[3] = 3;
      if (genes[0] === 0) genes[0] = 4;
      if (genes[4] === 0) genes[4] = 3;
      turtleAnim = null; traceAnim = null; useTrace = false;
      renderOpts = { flipY: true };
      showSliders(L_DEPTH, 8, { 0: { min: 1 }, 1: { min: 0 } });
      showToggles(null);
    },
    text: `
      <div class="step-title">Turtles all the way down</div>
      <div class="step-text">
        Each child turtle reaches its endpoint and <em>splits again</em>. And those children split again. <em>Depth</em> controls how many generations of splitting.
        <br><br>
        At depth 3, tips fork. At depth 4, those forks fork. The tree grows exponentially \u2014 2 branches become 6, then 14, then 30.
        <span class="action">Increase Depth to 3, then 4, then 5. Watch the tree explode.</span>
      </div>
    `,
  },

  // ═══ 7: Each Generation Gets Its Own Direction ═══
  {
    setup() {
      genes = [4, 3, -2, 3, 4, -3, 2, -2, 5];
      turtleAnim = null; traceAnim = null; useTrace = false;
      renderOpts = {};
      showSliders(L_ALL8, null);
      showToggles(null);
    },
    text: `
      <div class="step-title">Each level gets its own direction</div>
      <div class="step-text">
        Here's the key: each <em>generation</em> of turtles walks in a <em>different direction</em>. The first turtle uses Gene 1 (the stem). Its children use Genes 2+3 (inner branches). Their children use Genes 4+5 (middle). The next generation uses Genes 6+7 (outer).
        <br><br>
        That's why 8 direction genes exist \u2014 to give each depth level its own character.
        <span class="action">Try each slider pair. Notice how Genes 2+3 affect the inner branches while Genes 6+7 change the outer tips.</span>
      </div>
    `,
  },

  // ═══ 8: The Trunk ═══
  {
    setup() {
      turtleAnim = null; traceAnim = null; useTrace = false;
      renderOpts = {};
      showSliders(L_ALL9, 7);
      showToggles(null);
    },
    text: `
      <div class="step-title">The trunk</div>
      <div class="step-text">
        One more direction: <em>Gene 8</em> draws a trunk \u2014 or tail, or root \u2014 extending downward from the starting point. It also appears deep in the branching tree when levels wrap around.
        <br><br>
        That gives us <em>9 genes total</em>: 8 directions plus depth. The complete recipe for a biomorph.
        <span class="action">Drag Gene 8 to grow a trunk. Then play with all 9 to find a creature you like.</span>
      </div>
    `,
  },

  // ═══ 9: All 9 Genes ═══
  {
    setup() {
      turtleAnim = null; traceAnim = null; useTrace = false;
      renderOpts = {};
      showSliders(L_ALL9, null);
      showToggles(null);
    },
    text: `
      <div class="step-title">Nine genes, billions of forms</div>
      <div class="step-text">
        This is the basic Dawkins system. Every combination of 9 numbers produces a different creature. With each gene ranging from \u22129 to 9 and depth from 1 to 8, that's over <em>46 million</em> possible genotypes.
        <span class="quote">"Genes don't control small fragments of the body, the equivalent of pixels. Genes exert global growing rules, developmental processes, and embryological algorithms."
          <span class="quote-attr">\u2014 Dawkins, p. 206</span>
        </span>
        <span class="action">Explore freely. Try to make an insect, a fern, or a flower.</span>
      </div>
    `,
  },

  // ═══ 10: The Problem with Trees ═══
  {
    setup() {
      genes = [-4, 5, -2, 3, -6, 4, 7, -3, 7];
      turtleAnim = null; traceAnim = null; useTrace = false;
      renderOpts = {};
      showSliders(L_ALL9, null);
      showToggles(null);
    },
    text: `
      <div class="step-title">The problem with trees</div>
      <div class="step-text">
        With 9 genes you can make insects, ferns, spiders, foxes \u2014 but they're all <em>single branching trees</em>. Real animals have <em>repeating segments</em>: vertebrae, ribs, legs along a body.
        <br><br>
        Dawkins realized he needed a new embryological trick to get there.
        <span class="quote">"Not all evolutionary watersheds are as dramatic in their magnitude or in their consequences as the invention of segmentation."
          <span class="quote-attr">\u2014 Dawkins, p. 217</span>
        </span>
      </div>
    `,
  },

  // ═══ 11: Segments ═══
  {
    setup() {
      genes = [3, -2, 1, 5, -3, 4, -1, 2, 4, 1, 6];
      turtleAnim = null; traceAnim = null; useTrace = false;
      renderOpts = {};
      showSliders(L_SEGS, 9);
      showToggles(null);
    },
    text: `
      <div class="step-title">Segments</div>
      <div class="step-text">
        New gene: <em>Segments</em>. It repeats the entire tree body plan multiple times, stacked vertically \u2014 like vertebrae along a spine.
        <span class="quote">"It is probably fair to say that the invention of segmentation was one of the major innovations in the history of life, an invention that was made at least twice."
          <span class="quote-attr">\u2014 Dawkins, p. 209</span>
        </span>
        <span class="action">Set Segments to 3, then 5, then 8. Watch the creature grow a body.</span>
      </div>
    `,
  },

  // ═══ 12: Spacing ═══
  {
    setup() {
      genes[9] = genes[9] < 3 ? 4 : genes[9];
      turtleAnim = null; traceAnim = null; useTrace = false;
      renderOpts = {};
      showSliders(L_SPACING, 10);
      showToggles(null);
    },
    text: `
      <div class="step-title">Spacing</div>
      <div class="step-text">
        New gene: <em>Spacing</em>. It controls the distance between segments.
        <br><br>
        Small spacing = compact caterpillar. Large spacing = stretched centipede.
        <span class="action">Drag Spacing from 2 to 12. Watch the body compress and stretch.</span>
      </div>
    `,
  },

  // ═══ 13: Gradients ═══
  {
    setup() {
      if (genes.length < 13) genes = [...genes.slice(0, 11), 0, 0];
      genes[9] = Math.max(genes[9], 4);
      turtleAnim = null; traceAnim = null; useTrace = false;
      renderOpts = { gradients: true };
      showSliders(L_GRADS, 11);
      showToggles(null);
    },
    text: `
      <div class="step-title">Gradients</div>
      <div class="step-text">
        A caterpillar's segments aren't all identical. A crab's front claws differ from its back legs. <em>Grad 1</em> and <em>Grad 2</em> make the branch pattern <em>change gradually</em> from segment to segment.
        <span class="quote">"The segments of a millipede may all look pretty much the same, but many segmented animals taper, being broader at the front and narrower at the back."
          <span class="quote-attr">\u2014 Dawkins, p. 212</span>
        </span>
        <span class="action">Drag Grad 1 to 5 or \u22125. Watch the top and bottom segments diverge.</span>
      </div>
    `,
  },

  // ═══ 14: The Full System ═══
  {
    setup() {
      genes = randomInteresting(4);
      if (genes.length < 13) genes = [...genes, ...new Array(13 - genes.length).fill(0)];
      genes[9] = Math.max(genes[9], 3);
      turtleAnim = null; traceAnim = null; useTrace = false;
      renderOpts = { symmetry: 'left-right', gradients: true };
      showSliders(L_GRADS, null);
      showToggles([
        { label: 'left\u2011right', active: true,
          onClick() { renderOpts.symmetry = 'left-right'; renderOpts.radial = false; },
          isActive() { return renderOpts.symmetry === 'left-right' && !renderOpts.radial; } },
        { label: 'up\u2011down', active: false,
          onClick() { renderOpts.symmetry = 'up-down'; renderOpts.radial = false; },
          isActive() { return renderOpts.symmetry === 'up-down' && !renderOpts.radial; } },
        { label: 'four\u2011way', active: false,
          onClick() { renderOpts.symmetry = 'four-way'; renderOpts.radial = false; },
          isActive() { return renderOpts.symmetry === 'four-way' && !renderOpts.radial; } },
        { label: 'radial', active: false,
          onClick() { renderOpts.radial = !renderOpts.radial; },
          isActive() { return renderOpts.radial; } },
      ]);
    },
    text: `
      <div class="step-title">The full Dawkins system</div>
      <div class="step-text">
        <em>13 genes + symmetry options</em>. That's the complete toolkit from the 1988 paper. 9 direction genes, depth, segments, spacing, and two gradients.
        <br><br>
        Try <em>radial</em> symmetry \u2014 it copies the whole creature around a circle, like a starfish or sea urchin. The number of arms equals the segment count.
        <span class="quote">"I am talking about a kind of higher-level selection, a selection not for survivability but for <em>evolvability</em>."
          <span class="quote-attr">\u2014 Dawkins, p. 217</span>
        </span>
      </div>
    `,
    extra() {
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.textContent = 'Random creature';
      btn.addEventListener('click', () => {
        genes = randomInteresting(4);
        if (genes.length < 13) genes = [...genes, ...new Array(13 - genes.length).fill(0)];
        genes[9] = Math.max(genes[9], 3);
        showSliders(L_GRADS, null);
        draw();
      });
      $cw.appendChild(btn);
      const links = document.createElement('div');
      links.className = 'links-row';
      links.innerHTML = `
        <a href="../genome/">Open in Genome View</a>
        <a href="../breed.html">Open in Breeder</a>
        <a href="../dawkins-paper/">Read the Paper</a>
      `;
      $tp.appendChild(links);
    },
  },
];

// ── Navigation ──
function goTo(step) {
  if (step < 0 || step >= steps.length) return;
  currentStep = step;
  $hs.textContent = `${step + 1} / ${steps.length}`;
  $prev.disabled = step === 0;
  $next.disabled = step === steps.length - 1;
  $dots.querySelectorAll('.step-dot').forEach((d, i) => d.classList.toggle('active', i === step));
  $cw.querySelectorAll('.btn, .extra-row').forEach(b => b.remove());
  turtleAnim = null;
  traceAnim = null;
  useTrace = false;
  traceSkipCount = 0;
  traceSliderIndices = null;
  coordAnim = null;
  branchIntroAnim = null;
  useCoordAnim = false;
  showAllMode = null;
  steps[step].setup();
  draw();
  $tp.innerHTML = steps[step].text;
  if (steps[step].extra) steps[step].extra();
}

for (let i = 0; i < steps.length; i++) {
  const dot = document.createElement('div');
  dot.className = 'step-dot';
  dot.addEventListener('click', () => goTo(i));
  $dots.appendChild(dot);
}

$prev.addEventListener('click', () => goTo(currentStep - 1));
$next.addEventListener('click', () => goTo(currentStep + 1));
document.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT') return;
  if (e.key === 'ArrowLeft') goTo(currentStep - 1);
  if (e.key === 'ArrowRight') goTo(currentStep + 1);
});

$cw.appendChild(canvas);
$cw.appendChild($sliders);
$cw.appendChild($toggles);
goTo(0);

</script>
</body>
</html>
